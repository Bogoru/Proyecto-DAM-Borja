{"ast":null,"code":"import { Capacitor } from '@capacitor/core';\nimport { dataViewToHexString, hexStringToDataView } from './conversion';\nimport { BluetoothLe } from './plugin';\nimport { getQueue } from './queue';\nimport { parseUUID } from './validators';\nclass BleClientClass {\n  constructor() {\n    this.scanListener = null;\n    this.eventListeners = new Map();\n    this.queue = getQueue(true);\n  }\n  enableQueue() {\n    this.queue = getQueue(true);\n  }\n  disableQueue() {\n    this.queue = getQueue(false);\n  }\n  async initialize(options) {\n    await this.queue(async () => {\n      await BluetoothLe.initialize(options);\n    });\n  }\n  /**\n   * Reports whether BLE is enabled on this device.\n   * Always returns `true` on **web**.\n   * @deprecated Use `isEnabled` instead.\n   */\n  async getEnabled() {\n    return this.isEnabled();\n  }\n  async isEnabled() {\n    const enabled = await this.queue(async () => {\n      const result = await BluetoothLe.isEnabled();\n      return result.value;\n    });\n    return enabled;\n  }\n  async enable() {\n    await this.queue(async () => {\n      await BluetoothLe.enable();\n    });\n  }\n  async disable() {\n    await this.queue(async () => {\n      await BluetoothLe.disable();\n    });\n  }\n  async startEnabledNotifications(callback) {\n    await this.queue(async () => {\n      var _a;\n      const key = `onEnabledChanged`;\n      await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\n      const listener = await BluetoothLe.addListener(key, result => {\n        callback(result.value);\n      });\n      this.eventListeners.set(key, listener);\n      await BluetoothLe.startEnabledNotifications();\n    });\n  }\n  async stopEnabledNotifications() {\n    await this.queue(async () => {\n      var _a;\n      const key = `onEnabledChanged`;\n      await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\n      this.eventListeners.delete(key);\n      await BluetoothLe.stopEnabledNotifications();\n    });\n  }\n  async isLocationEnabled() {\n    const enabled = await this.queue(async () => {\n      const result = await BluetoothLe.isLocationEnabled();\n      return result.value;\n    });\n    return enabled;\n  }\n  async openLocationSettings() {\n    await this.queue(async () => {\n      await BluetoothLe.openLocationSettings();\n    });\n  }\n  async openBluetoothSettings() {\n    await this.queue(async () => {\n      await BluetoothLe.openBluetoothSettings();\n    });\n  }\n  async openAppSettings() {\n    await this.queue(async () => {\n      await BluetoothLe.openAppSettings();\n    });\n  }\n  async setDisplayStrings(displayStrings) {\n    await this.queue(async () => {\n      await BluetoothLe.setDisplayStrings(displayStrings);\n    });\n  }\n  async requestDevice(options) {\n    options = options ? this.validateRequestBleDeviceOptions(options) : undefined;\n    const result = await this.queue(async () => {\n      const device = await BluetoothLe.requestDevice(options);\n      return device;\n    });\n    return result;\n  }\n  async requestLEScan(options, callback) {\n    options = this.validateRequestBleDeviceOptions(options);\n    await this.queue(async () => {\n      var _a;\n      await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\n      this.scanListener = await BluetoothLe.addListener('onScanResult', resultInternal => {\n        const result = Object.assign(Object.assign({}, resultInternal), {\n          manufacturerData: this.convertObject(resultInternal.manufacturerData),\n          serviceData: this.convertObject(resultInternal.serviceData),\n          rawAdvertisement: resultInternal.rawAdvertisement ? this.convertValue(resultInternal.rawAdvertisement) : undefined\n        });\n        callback(result);\n      });\n      await BluetoothLe.requestLEScan(options);\n    });\n  }\n  async stopLEScan() {\n    await this.queue(async () => {\n      var _a;\n      await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\n      this.scanListener = null;\n      await BluetoothLe.stopLEScan();\n    });\n  }\n  async getDevices(deviceIds) {\n    return this.queue(async () => {\n      const result = await BluetoothLe.getDevices({\n        deviceIds\n      });\n      return result.devices;\n    });\n  }\n  async getConnectedDevices(services) {\n    if (!Array.isArray(services)) {\n      throw new Error('services must be an array');\n    }\n    services = services.map(parseUUID);\n    return this.queue(async () => {\n      const result = await BluetoothLe.getConnectedDevices({\n        services\n      });\n      return result.devices;\n    });\n  }\n  async connect(deviceId, onDisconnect, options) {\n    await this.queue(async () => {\n      var _a;\n      if (onDisconnect) {\n        const key = `disconnected|${deviceId}`;\n        await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\n        const listener = await BluetoothLe.addListener(key, () => {\n          onDisconnect(deviceId);\n        });\n        this.eventListeners.set(key, listener);\n      }\n      await BluetoothLe.connect(Object.assign({\n        deviceId\n      }, options));\n    });\n  }\n  async createBond(deviceId) {\n    await this.queue(async () => {\n      await BluetoothLe.createBond({\n        deviceId\n      });\n    });\n  }\n  async isBonded(deviceId) {\n    const isBonded = await this.queue(async () => {\n      const result = await BluetoothLe.isBonded({\n        deviceId\n      });\n      return result.value;\n    });\n    return isBonded;\n  }\n  async disconnect(deviceId) {\n    await this.queue(async () => {\n      await BluetoothLe.disconnect({\n        deviceId\n      });\n    });\n  }\n  async getServices(deviceId) {\n    const services = await this.queue(async () => {\n      const result = await BluetoothLe.getServices({\n        deviceId\n      });\n      return result.services;\n    });\n    return services;\n  }\n  async discoverServices(deviceId) {\n    await this.queue(async () => {\n      await BluetoothLe.discoverServices({\n        deviceId\n      });\n    });\n  }\n  async getMtu(deviceId) {\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.getMtu({\n        deviceId\n      });\n      return result.value;\n    });\n    return value;\n  }\n  async requestConnectionPriority(deviceId, connectionPriority) {\n    await this.queue(async () => {\n      await BluetoothLe.requestConnectionPriority({\n        deviceId,\n        connectionPriority\n      });\n    });\n  }\n  async readRssi(deviceId) {\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.readRssi({\n        deviceId\n      });\n      return parseFloat(result.value);\n    });\n    return value;\n  }\n  async read(deviceId, service, characteristic, options) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.read(Object.assign({\n        deviceId,\n        service,\n        characteristic\n      }, options));\n      return this.convertValue(result.value);\n    });\n    return value;\n  }\n  async write(deviceId, service, characteristic, value, options) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    return this.queue(async () => {\n      if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.write(Object.assign({\n        deviceId,\n        service,\n        characteristic,\n        value: writeValue\n      }, options));\n    });\n  }\n  async writeWithoutResponse(deviceId, service, characteristic, value, options) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.writeWithoutResponse(Object.assign({\n        deviceId,\n        service,\n        characteristic,\n        value: writeValue\n      }, options));\n    });\n  }\n  async readDescriptor(deviceId, service, characteristic, descriptor, options) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    descriptor = parseUUID(descriptor);\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.readDescriptor(Object.assign({\n        deviceId,\n        service,\n        characteristic,\n        descriptor\n      }, options));\n      return this.convertValue(result.value);\n    });\n    return value;\n  }\n  async writeDescriptor(deviceId, service, characteristic, descriptor, value, options) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    descriptor = parseUUID(descriptor);\n    return this.queue(async () => {\n      if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.writeDescriptor(Object.assign({\n        deviceId,\n        service,\n        characteristic,\n        descriptor,\n        value: writeValue\n      }, options));\n    });\n  }\n  async startNotifications(deviceId, service, characteristic, callback) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      var _a;\n      const key = `notification|${deviceId}|${service}|${characteristic}`;\n      await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\n      const listener = await BluetoothLe.addListener(key, event => {\n        callback(this.convertValue(event === null || event === void 0 ? void 0 : event.value));\n      });\n      this.eventListeners.set(key, listener);\n      await BluetoothLe.startNotifications({\n        deviceId,\n        service,\n        characteristic\n      });\n    });\n  }\n  async stopNotifications(deviceId, service, characteristic) {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      var _a;\n      const key = `notification|${deviceId}|${service}|${characteristic}`;\n      await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\n      this.eventListeners.delete(key);\n      await BluetoothLe.stopNotifications({\n        deviceId,\n        service,\n        characteristic\n      });\n    });\n  }\n  validateRequestBleDeviceOptions(options) {\n    if (options.services) {\n      options.services = options.services.map(parseUUID);\n    }\n    if (options.optionalServices) {\n      options.optionalServices = options.optionalServices.map(parseUUID);\n    }\n    return options;\n  }\n  convertValue(value) {\n    if (typeof value === 'string') {\n      return hexStringToDataView(value);\n    } else if (value === undefined) {\n      return new DataView(new ArrayBuffer(0));\n    }\n    return value;\n  }\n  convertObject(obj) {\n    if (obj === undefined) {\n      return undefined;\n    }\n    const result = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = this.convertValue(obj[key]);\n    }\n    return result;\n  }\n}\nexport const BleClient = new BleClientClass();","map":{"version":3,"names":["Capacitor","dataViewToHexString","hexStringToDataView","BluetoothLe","getQueue","parseUUID","BleClientClass","constructor","scanListener","eventListeners","Map","queue","enableQueue","disableQueue","initialize","options","getEnabled","isEnabled","enabled","result","value","enable","disable","startEnabledNotifications","callback","key","_a","get","remove","listener","addListener","set","stopEnabledNotifications","delete","isLocationEnabled","openLocationSettings","openBluetoothSettings","openAppSettings","setDisplayStrings","displayStrings","requestDevice","validateRequestBleDeviceOptions","undefined","device","requestLEScan","resultInternal","Object","assign","manufacturerData","convertObject","serviceData","rawAdvertisement","convertValue","stopLEScan","getDevices","deviceIds","devices","getConnectedDevices","services","Array","isArray","Error","map","connect","deviceId","onDisconnect","createBond","isBonded","disconnect","getServices","discoverServices","getMtu","requestConnectionPriority","connectionPriority","readRssi","parseFloat","read","service","characteristic","write","buffer","writeValue","getPlatform","writeWithoutResponse","readDescriptor","descriptor","writeDescriptor","startNotifications","event","stopNotifications","optionalServices","DataView","ArrayBuffer","obj","keys","BleClient"],"sources":["/Users/Misana/Desktop/Sensae/node_modules/@capacitor-community/bluetooth-le/src/bleClient.ts"],"sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\nimport { Capacitor } from '@capacitor/core';\n\nimport type { DisplayStrings } from './config';\nimport { dataViewToHexString, hexStringToDataView } from './conversion';\nimport type {\n  BleDevice,\n  BleService,\n  ConnectionPriority,\n  Data,\n  InitializeOptions,\n  ReadResult,\n  RequestBleDeviceOptions,\n  ScanResult,\n  ScanResultInternal,\n  TimeoutOptions,\n} from './definitions';\nimport { BluetoothLe } from './plugin';\nimport { getQueue } from './queue';\nimport { parseUUID } from './validators';\n\nexport interface BleClientInterface {\n  /**\n   * Initialize Bluetooth Low Energy (BLE). If it fails, BLE might be unavailable on this device.\n   * On **Android** it will ask for the location permission. On **iOS** it will ask for the Bluetooth permission.\n   * For an example, see [usage](#usage).\n   */\n  initialize(options?: InitializeOptions): Promise<void>;\n\n  /**\n   * Reports whether Bluetooth is enabled on this device.\n   * Always returns `true` on **web**.\n   */\n  isEnabled(): Promise<boolean>;\n\n  /**\n   * Enable Bluetooth.\n   * Only available on **Android**.\n   */\n  enable(): Promise<void>;\n\n  /**\n   * Disable Bluetooth.\n   * Only available on **Android**.\n   */\n  disable(): Promise<void>;\n\n  /**\n   * Register a callback function that will be invoked when Bluetooth is enabled (true) or disabled (false) on this device.\n   * Not available on **web** (the callback will never be invoked).\n   * @param callback Callback function to use when the Bluetooth state changes.\n   */\n  startEnabledNotifications(callback: (value: boolean) => void): Promise<void>;\n\n  /**\n   * Stop the enabled notifications registered with `startEnabledNotifications`.\n   */\n  stopEnabledNotifications(): Promise<void>;\n\n  /**\n   * Reports whether Location Services are enabled on this device.\n   * Only available on **Android**.\n   */\n  isLocationEnabled(): Promise<boolean>;\n\n  /**\n   * Open Location settings.\n   * Only available on **Android**.\n   */\n  openLocationSettings(): Promise<void>;\n\n  /**\n   * Open Bluetooth settings.\n   * Only available on **Android**.\n   */\n  openBluetoothSettings(): Promise<void>;\n\n  /**\n   * Open App settings.\n   * Not available on **web**.\n   * On **iOS** when a user declines the request to use Bluetooth on the first call of `initialize`, it is not possible\n   * to request for Bluetooth again from within the app. In this case Bluetooth has to be enabled in the app settings\n   * for the app to be able use it.\n   */\n  openAppSettings(): Promise<void>;\n\n  /**\n   * Set the strings that are displayed in the `requestDevice` dialog.\n   * @param displayStrings\n   */\n  setDisplayStrings(displayStrings: DisplayStrings): Promise<void>;\n\n  /**\n   * Request a peripheral BLE device to interact with. This will scan for available devices according to the filters in the options and show a dialog to pick a device.\n   * For an example, see [usage](#usage).\n   * @param options Device filters, see [RequestBleDeviceOptions](#RequestBleDeviceOptions)\n   */\n  requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice>;\n\n  /**\n   * Start scanning for BLE devices to interact with according to the filters in the options. The callback will be invoked on each device that is found.\n   * Scanning will continue until `stopLEScan` is called. For an example, see [usage](#usage).\n   * **NOTE**: Use with care on **web** platform, the required API is still behind a flag in most browsers.\n   * @param options\n   * @param callback\n   */\n  requestLEScan(options: RequestBleDeviceOptions, callback: (result: ScanResult) => void): Promise<void>;\n\n  /**\n   * Stop scanning for BLE devices. For an example, see [usage](#usage).\n   */\n  stopLEScan(): Promise<void>;\n\n  /**\n   * On iOS and web, if you want to connect to a previously connected device without scanning first, you can use `getDevice`.\n   * Uses [retrievePeripherals](https://developer.apple.com/documentation/corebluetooth/cbcentralmanager/1519127-retrieveperipherals) on iOS and\n   * [getDevices](https://developer.mozilla.org/en-US/docs/Web/API/Bluetooth/getDevices) on web.\n   * On Android, you can directly connect to the device with the deviceId.\n   * @param deviceIds List of device IDs, e.g. saved from a previous app run.\n   */\n  getDevices(deviceIds: string[]): Promise<BleDevice[]>;\n\n  /**\n   * Get a list of currently connected devices.\n   * Uses [retrieveConnectedPeripherals](https://developer.apple.com/documentation/corebluetooth/cbcentralmanager/1518924-retrieveconnectedperipherals) on iOS,\n   * [getConnectedDevices](https://developer.android.com/reference/android/bluetooth/BluetoothManager#getConnectedDevices(int)) on Android\n   * and [getDevices](https://developer.mozilla.org/en-US/docs/Web/API/Bluetooth/getDevices) on web.\n   * @param services List of services to filter the devices by. If no service is specified, no devices will be returned. Only applies to iOS.\n   */\n  getConnectedDevices(services: string[]): Promise<BleDevice[]>;\n\n  /**\n   * Connect to a peripheral BLE device. For an example, see [usage](#usage).\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param onDisconnect Optional disconnect callback function that will be used when the device disconnects\n   * @param options Options for plugin call\n   */\n  connect(deviceId: string, onDisconnect?: (deviceId: string) => void, options?: TimeoutOptions): Promise<void>;\n\n  /**\n   * Create a bond with a peripheral BLE device.\n   * Only available on **Android**. On iOS bonding is handled by the OS.\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  createBond(deviceId: string): Promise<void>;\n\n  /**\n   * Report whether a peripheral BLE device is bonded.\n   * Only available on **Android**. On iOS bonding is handled by the OS.\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  isBonded(deviceId: string): Promise<boolean>;\n\n  /**\n   * Disconnect from a peripheral BLE device. For an example, see [usage](#usage).\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  disconnect(deviceId: string): Promise<void>;\n\n  /**\n   * Get services, characteristics and descriptors of a device.\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  getServices(deviceId: string): Promise<BleService[]>;\n\n  /**\n   * Discover services, characteristics and descriptors of a device.\n   * You only need this method if your peripheral device changes its services and characteristics at runtime.\n   * If the discovery was successful, the remote services can be retrieved using the getServices function.\n   * Not available on **web**.\n   * @param deviceId  The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  discoverServices(deviceId: string): Promise<void>;\n\n  /**\n   * Get the MTU of a connected device. Note that the maximum write value length is 3 bytes less than the MTU.\n   * Not available on **web**.\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  getMtu(deviceId: string): Promise<number>;\n\n  /**\n   * Request a connection parameter update.\n   * Only available on **Android**. https://developer.android.com/reference/android/bluetooth/BluetoothGatt#requestConnectionPriority(int)\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param connectionPriority Request a specific connection priority. See [ConnectionPriority](#connectionpriority)\n   */\n  requestConnectionPriority(deviceId: string, connectionPriority: ConnectionPriority): Promise<void>;\n\n  /**\n   * Read the RSSI value of a connected device.\n   * Not available on **web**.\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   */\n  readRssi(deviceId: string): Promise<number>;\n\n  /**\n   * Read the value of a characteristic. For an example, see [usage](#usage).\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param options Options for plugin call\n   */\n  read(deviceId: string, service: string, characteristic: string, options?: TimeoutOptions): Promise<DataView>;\n\n  /**\n   * Write a value to a characteristic. For an example, see [usage](#usage).\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])\n   * @param options Options for plugin call\n   */\n  write(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void>;\n\n  /**\n   * Write a value to a characteristic without waiting for a response.\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])\n   * @param options Options for plugin call\n   */\n  writeWithoutResponse(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void>;\n\n  /**\n   * Read the value of a descriptor.\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param descriptor UUID of the descriptor (see [UUID format](#uuid-format))\n   * @param options Options for plugin call\n   */\n  readDescriptor(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    descriptor: string,\n    options?: TimeoutOptions\n  ): Promise<DataView>;\n\n  /**\n   * Write a value to a descriptor.\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param descriptor UUID of the descriptor (see [UUID format](#uuid-format))\n   * @param value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])\n   * @param options Options for plugin call\n   */\n  writeDescriptor(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    descriptor: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void>;\n\n  /**\n   * Start listening to changes of the value of a characteristic.\n   * Note that you should only start the notifications once per characteristic in your app and share the data and\n   * not call `startNotifications` in every component that needs the data.\n   * For an example, see [usage](#usage).\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   * @param callback Callback function to use when the value of the characteristic changes\n   */\n  startNotifications(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    callback: (value: DataView) => void\n  ): Promise<void>;\n\n  /**\n   * Stop listening to the changes of the value of a characteristic. For an example, see [usage](#usage).\n   * @param deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))\n   * @param service UUID of the service (see [UUID format](#uuid-format))\n   * @param characteristic UUID of the characteristic (see [UUID format](#uuid-format))\n   */\n  stopNotifications(deviceId: string, service: string, characteristic: string): Promise<void>;\n}\n\nclass BleClientClass implements BleClientInterface {\n  private scanListener: PluginListenerHandle | null = null;\n  private eventListeners = new Map<string, PluginListenerHandle>();\n  private queue = getQueue(true);\n\n  enableQueue() {\n    this.queue = getQueue(true);\n  }\n\n  disableQueue() {\n    this.queue = getQueue(false);\n  }\n\n  async initialize(options?: InitializeOptions): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.initialize(options);\n    });\n  }\n\n  /**\n   * Reports whether BLE is enabled on this device.\n   * Always returns `true` on **web**.\n   * @deprecated Use `isEnabled` instead.\n   */\n  async getEnabled(): Promise<boolean> {\n    return this.isEnabled();\n  }\n\n  async isEnabled(): Promise<boolean> {\n    const enabled = await this.queue(async () => {\n      const result = await BluetoothLe.isEnabled();\n      return result.value;\n    });\n    return enabled;\n  }\n\n  async enable(): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.enable();\n    });\n  }\n\n  async disable(): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.disable();\n    });\n  }\n\n  async startEnabledNotifications(callback: (value: boolean) => void): Promise<void> {\n    await this.queue(async () => {\n      const key = `onEnabledChanged`;\n      await this.eventListeners.get(key)?.remove();\n      const listener = await BluetoothLe.addListener(key, (result) => {\n        callback(result.value);\n      });\n      this.eventListeners.set(key, listener);\n      await BluetoothLe.startEnabledNotifications();\n    });\n  }\n\n  async stopEnabledNotifications(): Promise<void> {\n    await this.queue(async () => {\n      const key = `onEnabledChanged`;\n      await this.eventListeners.get(key)?.remove();\n      this.eventListeners.delete(key);\n      await BluetoothLe.stopEnabledNotifications();\n    });\n  }\n\n  async isLocationEnabled(): Promise<boolean> {\n    const enabled = await this.queue(async () => {\n      const result = await BluetoothLe.isLocationEnabled();\n      return result.value;\n    });\n    return enabled;\n  }\n\n  async openLocationSettings(): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.openLocationSettings();\n    });\n  }\n\n  async openBluetoothSettings(): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.openBluetoothSettings();\n    });\n  }\n\n  async openAppSettings(): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.openAppSettings();\n    });\n  }\n\n  async setDisplayStrings(displayStrings: DisplayStrings): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.setDisplayStrings(displayStrings);\n    });\n  }\n\n  async requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice> {\n    options = options ? this.validateRequestBleDeviceOptions(options) : undefined;\n    const result = await this.queue(async () => {\n      const device = await BluetoothLe.requestDevice(options);\n      return device;\n    });\n    return result;\n  }\n\n  async requestLEScan(options: RequestBleDeviceOptions, callback: (result: ScanResult) => void): Promise<void> {\n    options = this.validateRequestBleDeviceOptions(options);\n    await this.queue(async () => {\n      await this.scanListener?.remove();\n      this.scanListener = await BluetoothLe.addListener('onScanResult', (resultInternal: ScanResultInternal) => {\n        const result: ScanResult = {\n          ...resultInternal,\n          manufacturerData: this.convertObject(resultInternal.manufacturerData),\n          serviceData: this.convertObject(resultInternal.serviceData),\n          rawAdvertisement: resultInternal.rawAdvertisement\n            ? this.convertValue(resultInternal.rawAdvertisement)\n            : undefined,\n        };\n        callback(result);\n      });\n      await BluetoothLe.requestLEScan(options);\n    });\n  }\n\n  async stopLEScan(): Promise<void> {\n    await this.queue(async () => {\n      await this.scanListener?.remove();\n      this.scanListener = null;\n      await BluetoothLe.stopLEScan();\n    });\n  }\n\n  async getDevices(deviceIds: string[]): Promise<BleDevice[]> {\n    return this.queue(async () => {\n      const result = await BluetoothLe.getDevices({ deviceIds });\n      return result.devices;\n    });\n  }\n\n  async getConnectedDevices(services: string[]): Promise<BleDevice[]> {\n    if (!Array.isArray(services)) {\n      throw new Error('services must be an array');\n    }\n    services = services.map(parseUUID);\n    return this.queue(async () => {\n      const result = await BluetoothLe.getConnectedDevices({ services });\n      return result.devices;\n    });\n  }\n\n  async connect(deviceId: string, onDisconnect?: (deviceId: string) => void, options?: TimeoutOptions): Promise<void> {\n    await this.queue(async () => {\n      if (onDisconnect) {\n        const key = `disconnected|${deviceId}`;\n        await this.eventListeners.get(key)?.remove();\n        const listener = await BluetoothLe.addListener(key, () => {\n          onDisconnect(deviceId);\n        });\n        this.eventListeners.set(key, listener);\n      }\n      await BluetoothLe.connect({ deviceId, ...options });\n    });\n  }\n\n  async createBond(deviceId: string): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.createBond({ deviceId });\n    });\n  }\n\n  async isBonded(deviceId: string): Promise<boolean> {\n    const isBonded = await this.queue(async () => {\n      const result = await BluetoothLe.isBonded({ deviceId });\n      return result.value;\n    });\n    return isBonded;\n  }\n\n  async disconnect(deviceId: string): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.disconnect({ deviceId });\n    });\n  }\n\n  async getServices(deviceId: string): Promise<BleService[]> {\n    const services = await this.queue(async () => {\n      const result = await BluetoothLe.getServices({ deviceId });\n      return result.services;\n    });\n    return services;\n  }\n\n  async discoverServices(deviceId: string): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.discoverServices({ deviceId });\n    });\n  }\n\n  async getMtu(deviceId: string): Promise<number> {\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.getMtu({ deviceId });\n      return result.value;\n    });\n    return value;\n  }\n\n  async requestConnectionPriority(deviceId: string, connectionPriority: ConnectionPriority): Promise<void> {\n    await this.queue(async () => {\n      await BluetoothLe.requestConnectionPriority({ deviceId, connectionPriority });\n    });\n  }\n\n  async readRssi(deviceId: string): Promise<number> {\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.readRssi({ deviceId });\n      return parseFloat(result.value);\n    });\n    return value;\n  }\n\n  async read(deviceId: string, service: string, characteristic: string, options?: TimeoutOptions): Promise<DataView> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.read({\n        deviceId,\n        service,\n        characteristic,\n        ...options,\n      });\n      return this.convertValue(result.value);\n    });\n    return value;\n  }\n\n  async write(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    return this.queue(async () => {\n      if (!value?.buffer) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue: DataView | string = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.write({\n        deviceId,\n        service,\n        characteristic,\n        value: writeValue,\n        ...options,\n      });\n    });\n  }\n\n  async writeWithoutResponse(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      if (!value?.buffer) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue: DataView | string = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.writeWithoutResponse({\n        deviceId,\n        service,\n        characteristic,\n        value: writeValue,\n        ...options,\n      });\n    });\n  }\n\n  async readDescriptor(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    descriptor: string,\n    options?: TimeoutOptions\n  ): Promise<DataView> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    descriptor = parseUUID(descriptor);\n    const value = await this.queue(async () => {\n      const result = await BluetoothLe.readDescriptor({\n        deviceId,\n        service,\n        characteristic,\n        descriptor,\n        ...options,\n      });\n      return this.convertValue(result.value);\n    });\n    return value;\n  }\n\n  async writeDescriptor(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    descriptor: string,\n    value: DataView,\n    options?: TimeoutOptions\n  ): Promise<void> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    descriptor = parseUUID(descriptor);\n    return this.queue(async () => {\n      if (!value?.buffer) {\n        throw new Error('Invalid data.');\n      }\n      let writeValue: DataView | string = value;\n      if (Capacitor.getPlatform() !== 'web') {\n        // on native we can only write strings\n        writeValue = dataViewToHexString(value);\n      }\n      await BluetoothLe.writeDescriptor({\n        deviceId,\n        service,\n        characteristic,\n        descriptor,\n        value: writeValue,\n        ...options,\n      });\n    });\n  }\n\n  async startNotifications(\n    deviceId: string,\n    service: string,\n    characteristic: string,\n    callback: (value: DataView) => void\n  ): Promise<void> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      const key = `notification|${deviceId}|${service}|${characteristic}`;\n      await this.eventListeners.get(key)?.remove();\n      const listener = await BluetoothLe.addListener(key, (event: ReadResult) => {\n        callback(this.convertValue(event?.value));\n      });\n      this.eventListeners.set(key, listener);\n      await BluetoothLe.startNotifications({\n        deviceId,\n        service,\n        characteristic,\n      });\n    });\n  }\n\n  async stopNotifications(deviceId: string, service: string, characteristic: string): Promise<void> {\n    service = parseUUID(service);\n    characteristic = parseUUID(characteristic);\n    await this.queue(async () => {\n      const key = `notification|${deviceId}|${service}|${characteristic}`;\n      await this.eventListeners.get(key)?.remove();\n      this.eventListeners.delete(key);\n      await BluetoothLe.stopNotifications({\n        deviceId,\n        service,\n        characteristic,\n      });\n    });\n  }\n\n  private validateRequestBleDeviceOptions(options: RequestBleDeviceOptions): RequestBleDeviceOptions {\n    if (options.services) {\n      options.services = options.services.map(parseUUID);\n    }\n    if (options.optionalServices) {\n      options.optionalServices = options.optionalServices.map(parseUUID);\n    }\n    return options;\n  }\n\n  private convertValue(value?: Data): DataView {\n    if (typeof value === 'string') {\n      return hexStringToDataView(value);\n    } else if (value === undefined) {\n      return new DataView(new ArrayBuffer(0));\n    }\n    return value;\n  }\n\n  private convertObject(obj?: { [key: string]: Data }): { [key: string]: DataView } | undefined {\n    if (obj === undefined) {\n      return undefined;\n    }\n    const result: { [key: string]: DataView } = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = this.convertValue(obj[key]);\n    }\n    return result;\n  }\n}\n\nexport const BleClient = new BleClientClass();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}