{"ast":null,"code":"import { fromEvent, Observable } from 'rxjs';\nexport var ERR_CORDOVA_NOT_AVAILABLE = {\n  error: 'cordova_not_available'\n};\nexport var ERR_PLUGIN_NOT_INSTALLED = {\n  error: 'plugin_not_installed'\n};\nexport function getPromise(callback) {\n  var tryNativePromise = function () {\n    if (Promise) {\n      return new Promise(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error('No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.');\n    }\n  };\n  if (typeof window !== 'undefined' && window.angular) {\n    var doc = window.document;\n    var injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n    if (injector) {\n      var $q = injector.get('$q');\n      return $q(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    }\n    console.warn(\"Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.\");\n  }\n  return tryNativePromise();\n}\nexport function wrapPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var pluginResult, rej;\n  var p = getPromise(function (resolve, reject) {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return resolve(args);\n      }, function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return reject(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n    rej = reject;\n  });\n  // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n  if (pluginResult && pluginResult.error) {\n    p.catch(function () {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n  return p;\n}\nfunction wrapOtherPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  return getPromise(function (resolve, reject) {\n    var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({\n        error: 'unexpected_error'\n      });\n    }\n  });\n}\nfunction wrapObservable(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  return new Observable(function (observer) {\n    var pluginResult;\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return observer.next(args);\n      }, function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return observer.error(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n    }\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n    return function () {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n          }\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n        console.warn(e);\n      }\n    };\n  });\n}\n/**\n * Wrap the event with an observable\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\nfunction wrapEventObservable(event, element) {\n  element = typeof window !== 'undefined' && element ? get(window, element) : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\nexport function checkAvailability(plugin, methodName, pluginName) {\n  var pluginRef, pluginInstance, pluginPackage;\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n  pluginInstance = getPlugin(pluginRef);\n  if (!pluginInstance || !!methodName && typeof pluginInstance[methodName] === 'undefined') {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n  return true;\n}\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\nexport function instanceAvailability(pluginObj, methodName) {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\nexport function setIndex(args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ignore resolve and reject in case sync\n  if (opts.sync) {\n    return args;\n  }\n  // If the plugin method expects myMethod(success, err, options)\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push(function (err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    var obj = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    var setSuccessIndex = function () {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n    var setErrorIndex = function () {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n  return args;\n}\nexport function callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n  args = setIndex(args, opts, resolve, reject);\n  var availabilityCheck = checkAvailability(pluginObj, methodName);\n  if (availabilityCheck === true) {\n    var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\nexport function callInstance(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  args = setIndex(args, opts, resolve, reject);\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\nexport function getPlugin(pluginRef) {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n  return null;\n}\nexport function get(element, path) {\n  var paths = path.split('.');\n  var obj = element;\n  for (var i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n    obj = obj[paths[i]];\n  }\n  return obj;\n}\nexport function pluginWarn(pluginName, plugin, method) {\n  if (method) {\n    console.warn('Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.');\n  } else {\n    console.warn(\"Native: tried accessing the \" + pluginName + \" plugin but it's not installed.\");\n  }\n  if (plugin) {\n    console.warn(\"Install the \" + pluginName + \" plugin: 'ionic cordova plugin add \" + plugin + \"'\");\n  }\n}\n/**\n * @private\n * @param pluginName\n * @param method\n */\nexport function cordovaWarn(pluginName, method) {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn('Native: tried calling ' + pluginName + '.' + method + ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    } else {\n      console.warn('Native: tried accessing the ' + pluginName + ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    }\n  }\n}\n/**\n * @private\n */\nexport var wrap = function (pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n/**\n * @private\n */\nexport function wrapInstance(pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(function (observer) {\n        var pluginResult;\n        if (opts.destruct) {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return observer.next(args);\n          }, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return observer.error(args);\n          });\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n        }\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n        return function () {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n            }\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise(function (resolve, reject) {\n        var result;\n        if (opts.destruct) {\n          result = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return resolve(args);\n          }, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return reject(args);\n          });\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      var pluginResult_1, rej_1;\n      var p = getPromise(function (resolve, reject) {\n        if (opts.destruct) {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return resolve(args);\n          }, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            return reject(args);\n          });\n        } else {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        rej_1 = reject;\n      });\n      // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n      if (pluginResult_1 && pluginResult_1.error) {\n        p.catch(function () {});\n        typeof rej_1 === 'function' && rej_1(pluginResult_1.error);\n      }\n      return p;\n    }\n  };\n}","map":{"version":3,"names":["fromEvent","Observable","ERR_CORDOVA_NOT_AVAILABLE","error","ERR_PLUGIN_NOT_INSTALLED","getPromise","callback","tryNativePromise","Promise","resolve","reject","console","window","angular","doc","document","injector","element","querySelector","body","$q","get","warn","wrapPromise","pluginObj","methodName","args","opts","pluginResult","rej","p","destruct","callCordovaPlugin","_i","arguments","length","catch","wrapOtherPromise","then","wrapObservable","observer","next","bind","complete","clearFunction","clearWithArgs","e","constructor","getPluginName","wrapEventObservable","event","checkAvailability","plugin","pluginName","pluginRef","pluginInstance","pluginPackage","getPluginRef","getPluginInstallName","getPlugin","cordova","cordovaWarn","pluginWarn","instanceAvailability","_objectInstance","setIndex","sync","callbackOrder","unshift","callbackStyle","push","err","result","successName","errorName","obj","successIndex","errorIndex","setSuccessIndex","splice","setErrorIndex","availabilityCheck","apply","callInstance","path","paths","split","i","method","process","wrap","observable","eventObservable","otherPromise","wrapInstance","pluginResult_1","rej_1"],"sources":["/Users/Misana/Desktop/Sensae/src/@ionic-native/core/decorators/common.ts"],"sourcesContent":["import { fromEvent, Observable } from 'rxjs';\n\nimport { CordovaOptions } from './interfaces';\n\ndeclare const window: any;\n\nexport const ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };\nexport const ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };\n\nexport function getPromise<T>(callback: (resolve: Function, reject?: Function) => any): Promise<T> {\n  const tryNativePromise = () => {\n    if (Promise) {\n      return new Promise<T>((resolve, reject) => {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error(\n        'No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.'\n      );\n    }\n  };\n\n  if (typeof window !== 'undefined' && window.angular) {\n    const doc = window.document;\n    const injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n    if (injector) {\n      const $q = injector.get('$q');\n      return $q((resolve: Function, reject: Function) => {\n        callback(resolve, reject);\n      });\n    }\n    console.warn(\n      `Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.`\n    );\n  }\n\n  return tryNativePromise();\n}\n\nexport function wrapPromise(pluginObj: any, methodName: string, args: any[], opts: CordovaOptions = {}) {\n  let pluginResult: any, rej: Function;\n  const p = getPromise((resolve: Function, reject: Function) => {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => resolve(args),\n        (...args: any[]) => reject(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n    rej = reject;\n  });\n  // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n  if (pluginResult && pluginResult.error) {\n    p.catch(() => {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n  return p;\n}\n\nfunction wrapOtherPromise(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return getPromise((resolve: Function, reject: Function) => {\n    const pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({ error: 'unexpected_error' });\n    }\n  });\n}\n\nfunction wrapObservable(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return new Observable(observer => {\n    let pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => observer.next(args),\n        (...args: any[]) => observer.error(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        observer.next.bind(observer),\n        observer.error.bind(observer)\n      );\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n    return () => {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(\n              pluginObj,\n              opts.clearFunction,\n              args,\n              opts,\n              observer.next.bind(observer),\n              observer.error.bind(observer)\n            );\n          }\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn(\n          'Unable to clear the previous observable watch for',\n          pluginObj.constructor.getPluginName(),\n          methodName\n        );\n        console.warn(e);\n      }\n    };\n  });\n}\n\n/**\n * Wrap the event with an observable\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\nfunction wrapEventObservable(event: string, element: any): Observable<any> {\n  element =\n    typeof window !== 'undefined' && element\n      ? get(window, element)\n      : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\n\n/**\n * Checks if plugin/cordova is available\n * @return {boolean | { error: string } }\n * @private\n */\nexport function checkAvailability(\n  pluginRef: string,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(\n  pluginObj: any,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(plugin: any, methodName?: string, pluginName?: string): boolean | { error: string } {\n  let pluginRef, pluginInstance, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || (!!methodName && typeof pluginInstance[methodName] === 'undefined')) {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\nexport function instanceAvailability(pluginObj: any, methodName?: string): boolean {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\n\nexport function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {\n  // ignore resolve and reject in case sync\n  if (opts.sync) {\n    return args;\n  }\n\n  // If the plugin method expects myMethod(success, err, options)\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push((err: any, result: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    const obj: any = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    const setSuccessIndex = () => {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    const setErrorIndex = () => {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n  return args;\n}\n\nexport function callCordovaPlugin(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n  args = setIndex(args, opts, resolve, reject);\n\n  const availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    const pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n\nexport function callInstance(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\n\nexport function getPlugin(pluginRef: string): any {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n  return null;\n}\n\nexport function get(element: Element | Window, path: string) {\n  const paths: string[] = path.split('.');\n  let obj: any = element;\n  for (let i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n    obj = obj[paths[i]];\n  }\n  return obj;\n}\n\nexport function pluginWarn(pluginName: string, plugin?: string, method?: string): void {\n  if (method) {\n    console.warn(\n      'Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.'\n    );\n  } else {\n    console.warn(`Native: tried accessing the ${pluginName} plugin but it's not installed.`);\n  }\n  if (plugin) {\n    console.warn(`Install the ${pluginName} plugin: 'ionic cordova plugin add ${plugin}'`);\n  }\n}\n\n/**\n * @private\n * @param pluginName\n * @param method\n */\nexport function cordovaWarn(pluginName: string, method?: string): void {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn(\n        'Native: tried calling ' +\n          pluginName +\n          '.' +\n          method +\n          ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    } else {\n      console.warn(\n        'Native: tried accessing the ' +\n          pluginName +\n          ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    }\n  }\n}\n\n// Fixes a bug in TypeScript 2.9.2 where the ...args is being converted into args: {} and\n// causing compilation issues\nexport type WrapFn = (...args: any[]) => any;\n\n/**\n * @private\n */\nexport const wrap = (pluginObj: any, methodName: string, opts: CordovaOptions = {}): WrapFn => {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n\n/**\n * @private\n */\nexport function wrapInstance(pluginObj: any, methodName: string, opts: any = {}): Function {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(observer => {\n        let pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => observer.next(args),\n            (...args: any[]) => observer.error(args)\n          );\n        } else {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            observer.next.bind(observer),\n            observer.error.bind(observer)\n          );\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n\n        return () => {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(\n                pluginObj,\n                opts.clearFunction,\n                args,\n                opts,\n                observer.next.bind(observer),\n                observer.error.bind(observer)\n              );\n            }\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn(\n              'Unable to clear the previous observable watch for',\n              pluginObj.constructor.getPluginName(),\n              methodName\n            );\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise((resolve: Function, reject: Function) => {\n        let result;\n        if (opts.destruct) {\n          result = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      let pluginResult: any, rej: Function;\n      const p = getPromise((resolve: Function, reject: Function) => {\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        rej = reject;\n      });\n      // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n      if (pluginResult && pluginResult.error) {\n        p.catch(() => {});\n        typeof rej === 'function' && rej(pluginResult.error);\n      }\n      return p;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}